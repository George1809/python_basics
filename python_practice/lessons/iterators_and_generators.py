import itertools

#Iterators - an object which allows a programmer to traverse through all the elements of a collection

my_list = [1,2,3,4,5,6,7]

my_iter = iter(my_list) # iter() returns an interator object

print (next(my_iter)) # in Python 2 and 3, it returns the elements of a sequence one by one; raises StopIteration when the sequence is exhausted
print (next(my_iter)) # schip the next iterator
print (next(my_iter))

print(list(my_iter))
print("---------------------------------------------------------------------------------------------")

#Generators - special routines that can be used to control the iteration behavior of a loop; defined using the "def" keyword;

def my_gen(x, y): #creating a generator function
    for i in range(x):
        print("i is %d" % i)
        print("y is %d" % y)
        yield i * y #yields the values one at a time; traversing a sequence up to a certain point, getting the result and suspending the execution

my_object = my_gen(10, 5) #creating a generator object

next(my_object) #manually yield the next element returned by the my_gen()function; raises StopIteration when the sequence is exhausted
print("----------")
print("----------")

rez = next(my_object), 
next(my_object), 
next(my_object), 
next(my_object), 
next(my_object), 
next(my_object),
next(my_object), 
next(my_object),
next(my_object)

print("----------")
print("----------")

gen_exp = (x for x in range(5)) #creating a generator expression; similar to list comprehensions, but using parentheses instead of square brackets
print(next(gen_exp))
print(next(gen_exp))
print(next(gen_exp))
print(next(gen_exp))
print(next(gen_exp)) #extracting each value in the list generated by range(5), one value at a time; raises StopIteration when the sequence is exhausted


#Itertools - built-in Python module for working with iterable data sets


print("--------------------------------")

list1 = [1, 2, 3, 'a', 'b', 'c']
list2 = [101, 102, 103, 'X', 'Y']

#chain() - takes several sequences and chains them together
print(list(itertools.chain(list1, list2)))

print("")

#count() - returns an iterator that generates consecutive integers until you stop it, otherwise it will go on forever
for i in itertools.count(10, 2.5):
    if i <= 50:
        print(i)
    else:
        print("Stoped")
        break #result is printing the numbers between 10 and 50 inclusively, with a step of 2.5



for i in range(1, 8, 2):
    print(i)
    i += 1


    print("-------------------------")

#cycle() - returns an iterator that simply repeats the value given as argument infinitely; you have to find a way to break out of the infinite loop
a = range(11, 16)

#for i in itertools.cycle(a):
#   print(i) #use Ctrl+C to break out of the infinite loop


b = list(a)

for i, h in enumerate((itertools.cycle(b))):
   print(h) 
   if i == 14:      
        break # limit cycle, after 14 iterations

    




#filterfalse() - returns the elements for which the function you give as argument returns False

print(list(itertools.filterfalse(lambda x: x < 5, [1, 2, 3, 4, 5, 6, 7]))) # what is not in the condition
#in Python 2 the result is [5, 6, 7]; in Python 3 there is no ifilter() like in Python 2, just filter() and filterfalse()


print("-------------------------")

#islice() - performs slicing; we can specify a starting point of the slice, an end point and a step
print (list(itertools.islice(range(111), 2, 18, 2))) #result is [2, 4, 6, 8]